<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="d3.slider.css" />
    <style>
        body {
            background-color: white;
        }
        
        svg {
            border: 2px solid white;
            background-color: aliceblue;
        }
        
        .selected {
            fill: #99ccff;
        }
        
        .boundary {
            fill: white;
            stroke: black;
            stroke-width: 1px;
        }
        
        .hidden {
            display: none;
        }
        
        div.tooltip {
            color: #222;
            background: #fff;
            border-radius: 3px;
            box-shadow: 0px 0px 2px 0px #a6a6a6;
            padding: .2em;
            text-shadow: #f5f5f5 0 1px 0;
            opacity: 0.9;
            position: absolute;
        }
        
        .site {
            stroke-width: .5px;
            stroke: white;
            fill: pink;
            opacity: 0.5;
        }
        
        #slider3 {
            margin: 20px 0 10px 20px;
            width: 900px;
        }

    </style>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.3/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="d3.slider.js"></script>

</head>

<body>
    <div id="slider3"></div>
    <div id="map"></div>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.3/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="d3.slider.js"></script>
    <script>
        var width = 962,
            rotated = 90,
            height = 1000;

        //countries which have states, needed to toggle visibility
        //for USA/ etc. either show countries or states, not both
        var usa, canada;
        var states; //track states
        //track where mouse was clicked
        var initX;
        //track scale only rotate when s === 1
        var s = 1;
        var mouseClicked = false;

        var xAxisScale = d3.scale.linear()
            .domain([0, width])
            .range([0, width]);

        var yAxisScale = d3.scale.linear()
            .domain([0, height])
            .range([height, 0]);

        // initial position of projection
        var projection = d3.geo.mercator()
            .center([0, -25])
            .scale(600)
            .translate([300, height / 1.5])
            .rotate([rotated, 0, 0]); //center on USA because 'murica

        var zoom = d3.behavior.zoom()
            .scaleExtent([1, 10])
            .x(xAxisScale)
            .y(xAxisScale)
            .on("zoom", zoomed);

        function zoomed() {
            var t = d3.event.translate;
            s = d3.event.scale;
            var h = 0;

            t[0] = Math.min(
                (width / height) * (s - 1),
                Math.max(width * (1 - s), t[0])
            );

            t[1] = Math.min(
                h * (s - 1) + h * s,
                Math.max(height * (1 - s) - h * s, t[1])
            );

            zoom.translate(t);
            if (s === 1 && mouseClicked) {
                rotateMap(d3.mouse(this)[0])
                return;
            }

            g.attr("transform", "translate(" + t + ")scale(" + s + ")");

            //adjust the stroke width based on zoom level
            d3.selectAll(".boundary")
                .style("stroke-width", 1 / s);

            //toggle state/USA visability
            if (s > 1.5) {
                states.classed('hidden', false);
                usa.classed('hidden', true);
                canada.classed('hidden', true);
            } else {
                states.classed('hidden', true);
                usa.classed('hidden', false);
                canada.classed('hidden', false);
            };
            var circles = d3.select("svg").selectAll("circle");
            circles
                .attr("cx", function(d, i) {
                    return projection([xAxisScale(d.cx), yAxisScale(d.cy)])[0]
                })
                .attr("cy", function(d, i) {
                    return projection([xAxisScale(d.cx), yAxisScale(d.cy)])[1]
                })
//                .transition()
//                .duration(750)
//                .attr("transform", function(d) {
//                    var t = d3.transform(d3.select(this).attr("transform")).translate; //maintain aold marker translate 
//                    return "translate(" + t[0] + "," + t[1] + ")scale(" + 1 / scale + ")"; //inverse the scale of parent
//                });
//            var bounds = path.bounds(d),
//                dx = bounds[1][0] - bounds[0][0],
//                dy = bounds[1][1] - bounds[0][1],
//                x = (bounds[0][0] + bounds[1][0]) / 2,
//                y = (bounds[0][1] + bounds[1][1]) / 2,
//                scale = .9 / Math.max(dx / width, dy / height),
//                translate = [width / 2 - scale * x, height / 2 - scale * y];

//            g.selectAll(".site")
//                .transition()
//                .duration(750)
//                .attr("transform", function(d) {
//                    var t = d3.transform(d3.select(this).attr("transform")).translate; //maintain aold marker translate 
//                    return "translate(" + t[0] + "," + t[1] + ")scale(" + 1   + ")"; //inverse the scale of parent
//                });
        }
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            //track where user clicked down
            .on("mousedown", function() {
                d3.event.preventDefault();
                //only if scale === 1
                if (s !== 1) return;
                initX = d3.mouse(this)[0];
                mouseClicked = true;
            })
            .on("mouseup", function() {
                if (s !== 1) return;
                rotated = rotated + ((d3.mouse(this)[0] - initX) * 360 / (s * width));
                mouseClicked = false;
            })
            .call(zoom);


        function rotateMap(endX) {
            projection.rotate([rotated + (endX - initX) * 360 / (s * width), 0, 0])
            g.selectAll('path') // re-project path data
                .attr('d', path);
        }
        //for tooltip 
        var offsetL = document.getElementById('map').offsetLeft + 10;
        var offsetT = document.getElementById('map').offsetTop + 10;

        var path = d3.geo.path()
            .projection(projection);

        var tooltip = d3.select("#map")
            .append("div")
            .attr("class", "tooltip hidden");

        //need this for correct panning
        var g = svg.append("g");
        var zikadata = []
        //det json data and draw it
        d3.json("combined2.json", function(error, world) {
            if (error) return console.error(error);

            //countries
            g.append("g")
                .attr("class", "boundary")
                .selectAll("boundary")
                .data(topojson.feature(world, world.objects.countries).features)
                .enter().append("path")
                .attr("name", function(d) {
                    return d.properties.name;
                })
                .attr("id", function(d) {
                    return d.id;
                })
                .on('click', selected)
                .on("mousemove", showTooltip)
                .on("mouseout", function(d, i) {
                    tooltip.classed("hidden", true);
                })
                .attr("d", path);

            usa = d3.select('#USA');
            canada = d3.select('#CAN');

            //states
            g.append("g")
                .attr("class", "boundary state hidden")
                .selectAll("boundary")
                .data(topojson.feature(world, world.objects.states).features)
                .enter().append("path")
                .attr("name", function(d) {
                    return d.properties.name;
                })
                .attr("id", function(d) {
                    return d.id;
                })
                .on('click', selected)
                .on("mousemove", showTooltip)
                .on("mouseout", function(d, i) {
                    tooltip.classed("hidden", true);
                })
                .attr("d", path);

            states = d3.selectAll('.state');

            //attach initial data
            d3.csv("zika_SA_sample.csv", function(error, data) {
                    //var formatDate = d3.time.format("%Y-%m-%d");
                    var minDate = moment("2016-04-02", "YYYY MM DD").unix();
                    data.forEach(function(d) {
                        zikadata.push({
                            date: moment(d.report_date, "YYYY-MM-DD HH:mm:ss").unix(),
                            lon: +d.lon,
                            lat: +d.lat
                        })
                    });

                    var filtered = data.filter(function(row) {
                        return row.date < minDate;
                    })
                    g.selectAll(".site")
                        .data(filtered).enter()
                        .append("a").append("circle")
                        .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                        })
                        .attr("r", 1)
                        .attr("transform", function(d) {
                            return "translate(" + projection([d.lon, d.lat]) + ")";
                        });;


                })
                .get(function(err, rows) {
                    if (err) return console.error(err);

                    window.site_data = rows;
                });
        });

        console.log(zikadata)

        function showTooltip(d) {
            label = d.properties.name;
            var mouse = d3.mouse(svg.node())
                .map(function(d) {
                    return parseInt(d);
                });
            tooltip.classed("hidden", false)
                .attr("style", "left:" + (mouse[0] + offsetL) + "px;top:" + (mouse[1] + offsetT) + "px")
                .html(label);
        }

        function selected() {
            d3.select('.selected').classed('selected', false);
            d3.select(this).classed('selected', true);
        }



        var displaySites = function(data) {
            var sites = g.selectAll(".site")
                .data(data)
            sites.enter().append("circle")
                .attr("class", "site")
                .attr("cx", function(d) {
                    return projection([d.lon, d.lat])[0];
                })
                .attr("cy", function(d) {
                    return projection([d.lon, d.lat])[1];
                })
                .attr("transform", function(d) {
                    return "translate(" + projection([d.long, d.lat]) + ")";
                })
                .attr("r", 0)
                .transition().duration(50)
                .attr("r", 2);

            sites.exit()
                //.transition().duration(200)
                .attr("r", 0)
                .remove();
        };

        var minDateUnix = moment('2015-12-05', "YYYY MM DD").unix();
        var maxDateUnix = moment('2016-07-02', "YYYY MM DD").unix();
        var secondsInDay = 60 * 60 * 24;

        d3.select('#slider3').call(
            d3.slider()
            .axis(true).min(minDateUnix).max(maxDateUnix).step(secondsInDay)
            .on("slide", function(evt, value) {
                var newData = _(site_data).filter(function(site) {
                    var date = moment(site.report_date, "YYYY-MM-DD").unix()
                    return date < value;
                })
                displaySites(newData);
            })
        );




        //            .get(function(err, rows) {
        //                if (err) return console.error(err);
        //                window.site_data = rows;
        //            });

    </script>
</body>

</html>
